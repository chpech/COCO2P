# # a poset is a set of elements endowed with a partial order relation 
# #rec(
# #    elements= [],      # list of all elements of the poset. The list must be
# #                       # ordered in a way that is compatible with the partial
# #                       # order relation (no element is preceeded by a greater element).  
# #    successors= [],    # on index i the list of all indices of successors of the
# #                       # element #i is stored  
# #    predecessors= []   # the same as successors for predecessors
# #    );
# #
# # input:  <poset> --- a partially ordered set
# #         <elm>   --- the index of an element of <poset>
# # output: the list of successors of <elm> in <poset>
# InstallGlobalFunction(PosetSuccessors,
# function(poset, elm)
#     return poset.successors[elm];
# end);

# # input:  <poset> --- a partially ordered set
# #         <elm>   --- the index of an element of <poset>
# # output: the list of predecessors of <elm> in <poset>
# InstallGlobalFunction(PosetPredecessors,
# function(poset, elm)
#     return poset.predecessors[elm];
# end);




# # input:  <poset> --- a partially ordered set
# #         <elm>   --- the index of an element of <poset>
# # output: the set of elements of the principal filter generated by <elm>
# InstallGlobalFunction(PosetPrincipalFilter,
# function(poset,elm)
#     local filter,succ;
    
#     filter:=[elm];
#     succ:=[elm];
#     repeat
#         succ:=Set(Concatenation(List(succ, x->PosetSuccessors(poset,x))));
#         UniteSet(filter, succ);
#     until succ=[];
#     return filter;
# end);

# # input:  <poset> --- a partially ordered set 
# #         <elm>   --- the index of an element of <poset>
# # output: the set of elements of the principal ideal generated by <elm>
# InstallGlobalFunction(PosetPrincipalIdeal,
# function(poset,elm)
#     local ideal,pred;
    
#     ideal:=[elm];
#     pred:=[elm];
#     repeat
#         pred:=Set(Concatenation(List(pred, x->PosetPredecessors(poset,x))));
#         UniteSet(ideal, pred);
#     until pred=[];
#     return ideal;
# end);



# ##############################################################
# #  new experimental functions                                #
# ##############################################################


# InstallGlobalFunction(PosetFilter,
# function(pos,m)
#    return Union(List(m, x->PosetPrincipalFilter(pos,x)));
# end);

# InstallGlobalFunction(PosetIdeal,
# function(pos,m)
#    return Union(List(m, x->PosetPrincipalIdeal(pos,x)));
# end);

# InstallGlobalFunction(PosetMinimalElements,
# function(pos,m)
#    return Filtered(m, x->Intersection(PosetPrincipalIdeal(pos,x),m)=[x]);
# end);

# InstallGlobalFunction(PosetMaximalElements,
# function(pos,m)
#    return Filtered(m, x->Intersection(PosetPrincipalFilter(pos,x),m)=[x]);
# end);

# InstallGlobalFunction(PosetCleanup,
# function(pos)
#    local i;
   
#    for i in [1..Length(pos.elements)] do
#       pos.successors[i]:=PosetMinimalElements(pos, PosetFilter(pos,pos.successors[i]));
#       pos.predecessors[i]:=PosetMaximalElements(pos, PosetIdeal(pos,pos.predecessors[i]));
#    od;
#    return pos;
# end);


# InstallGlobalFunction(PosetInducedPoset,
# function(pos,m)
#    local map,i,newpos,x,flt,id,succ,pred;
   
#    map:=[];
#    for i in [1..Length(m)] do
#       map[m[i]]:=i;
#    od;

#    newpos:=rec();
#    newpos.elements:=m;
#    newpos.successors:=List(m,x->[]);
#    newpos.predecessors:=List(m, x->[]);
#    for x in m do
#       flt:=PosetPrincipalFilter(pos,x);
#       RemoveSet(flt,x);
#       succ:=Union(PosetMinimalElements(pos,Intersection(flt,m)), Intersection(PosetSuccessors(pos,x),m));
#       newpos.successors[map[x]]:=List(succ, x->map[x]);
#       id:=PosetPrincipalIdeal(pos,x);
#       RemoveSet(id,x);
#       pred:=PosetMaximalElements(pos, Intersection(id,m));
#       newpos.predecessors[map[x]]:=List(pred, x->map[x]);
#    od;
   
#    return newpos;
# end);


# InstallGlobalFunction(PosetAllChains,
# function(pos,a,b)
#    local recure,idl;
   
#    recure:=function(x)
#       local next,chains;
   
#       if not x in idl then
#          return [];
#       fi;
#       if x=b then 
#          return [[x]];
#       fi;
#       next:=Intersection(PosetSuccessors(pos,x),idl);
#       chains:=Concatenation(List(next, y->recure(y)));
#       return List(chains, y->Concatenation([x],y));
#    end;

#    idl:=PosetPrincipalIdeal(pos,b);
#    return recure(a);
# end);

CocoPosetFam := NewFamily("CocoPosetFam", IsCocoPoset);

DeclareRepresentation( "IsCocoPosetRep", 
        IsAttributeStoringRep,
        ["elements",     # list of all elements of the poset. The list must be
                         # ordered in a way that is compatible with the partial
                         # order relation (no element is preceeded by a greater element). 
         "successors",   # on index i the list of all indices of successors of the
                         # element #i is stored
         "predecessors", # the same as successors for predecessors
         ]);

# input:  <poset> --- a partially ordered set
#         <elm>   --- the index of an element of <poset>
# output: the list of successors of <elm> in <poset>
InstallMethod(SuccessorsInCocoPoset,
        "for COCO-posets",
        [IsCocoPoset and IsCocoPosetRep, IsPosInt],
function(poset, elm)
    return poset!.successors[elm];
end);

InstallOtherMethod(Size,
        "for COCO-posets",
        [IsCocoPoset],
function(poset)
    return Length(ElementsOfCocoPoset(poset));
end);

InstallMethod(ElementsOfCocoPoset,
        "for COCO-posets",
        [IsCocoPoset and IsCocoPosetRep],
function(poset)
    return poset!.elements;
end);


# input:  <poset> --- a partially ordered set
#         <elm>   --- the index of an element of <poset>
# output: the list of predecessors of <elm> in <poset>
InstallMethod(PredecessorsInCocoPoset,
        "for COCO-posets",
        [IsCocoPoset and IsCocoPosetRep, IsPosInt],
function(poset, elm)
    return poset!.predecessors[elm];
end);

# input:  <poset> --- a partially ordered set
#         <elm>   --- the index of an element of <poset>
# output: the set of elements of the principal filter generated by <elm>
InstallMethod(FilterInCocoPoset,
        "for COCO-posets",
        [IsCocoPoset, IsPosInt],
function(poset,elm)
    local filter,succ;
    
    filter:=[elm];
    succ:=[elm];
    repeat
        succ:=Set(Concatenation(List(succ, x->SuccessorsInCocoPoset(poset,x))));
        UniteSet(filter, succ);
    until succ=[];
    return filter;
end);

InstallOtherMethod(FilterInCocoPoset,
        "for COCO-posets",
        [IsCocoPoset, IsSet],
function(pos,m)
   return Union(List(m, x->FilterInCocoPoset(pos,x)));
end);

# input:  <poset> --- a partially ordered set 
#         <elm>   --- the index of an element of <poset>
# output: the set of elements of the principal ideal generated by <elm>
InstallMethod(IdealInCocoPoset,
        "for COCO-posets",
        [IsCocoPoset, IsPosInt],
function(poset,elm)
    local ideal,pred;
    
    ideal:=[elm];
    pred:=[elm];
    repeat
        pred:=Set(Concatenation(List(pred, x->PredecessorsInCocoPoset(poset,x))));
        UniteSet(ideal, pred);
    until pred=[];
    return ideal;
end);

InstallOtherMethod(IdealInCocoPoset,
        "for COCO-posets",
        [IsCocoPoset, IsSet],
function(pos,m)
   return Union(List(m, x->IdealInCocoPoset(pos,x)));
end);

InstallMethod(MinimalElementsInCocoPoset,
        "for COCO-posets",
        [IsCocoPoset, IsSet],
function(pos,m)
   return Filtered(m, x->Intersection(IdealInCocoPoset(pos,x),m)=[x]);
end);

InstallMethod(MaximalElementsInCocoPoset,
        "for COCO-posets",
        [IsCocoPoset, IsSet],
function(pos,m)
   return Filtered(m, x->Intersection(FilterInCocoPoset(pos,x),m)=[x]);
end);

InstallGlobalFunction(InducedCocoPoset,
function(pos,m)
   local map,i,newpos,x,flt,id,succ,pred;
   
   map:=[];
   for i in [1..Length(m)] do
      map[m[i]]:=i;
   od;

   newpos:=rec();
   newpos.elements:=m;
   newpos.successors:=List(m,x->[]);
   newpos.predecessors:=List(m, x->[]);
   for x in m do
      flt:=FilterInCocoPoset(pos,x);
      RemoveSet(flt,x);
      succ:=Union(MinimalElementsInCocoPoset(pos,Intersection(flt,m)), Intersection(SuccessorsInCocoPoset(pos,x),m));
      newpos.successors[map[x]]:=List(succ, x->map[x]);
      id:=IdealInCocoPoset(pos,x);
      RemoveSet(id,x);
      pred:=MaximalElementsInCocoPoset(pos, Intersection(id,m));
      newpos.predecessors[map[x]]:=List(pred, x->map[x]);
   od;
   return Objectify(NewType(CocoPosetFam, IsCocoPosetRep), newpos);
end);

# elements is a set of objects
# order is a binary boolean function
# order(x,y)=true if and only of x is below y
# linorder is a binary boolean function that defines a linearization of order
InstallGlobalFunction(CocoPosetByFunctions,
function(elements,order,linorder)
    local   poset,  i,  active,  j;
    
#    Sort(elements, function(x,y) return linorder(y,x);end);
    Sort(elements, linorder);
    
    poset:=rec();
    poset.elements:=Immutable(elements);
    poset.successors:=List(elements, x->[]);
    poset.predecessors:=List(elements,x->[]);
    poset:=Objectify(NewType(CocoPosetFam, IsCocoPosetRep), poset);
    
    for i in [Length(elements),Length(elements)-1..1] do
        active:=[i+1..Length(elements)];
        while active<>[] do
            j:=active[1]; active:=active{[2..Length(active)]};
            if order(elements[i],elements[j]) then
                Add(poset!.successors[i],j);
                Add(poset!.predecessors[j],i);
                SubtractSet(active,FilterInCocoPoset(poset,j));
            fi;
        od;
    od;
    MakeImmutable(poset!.successors);
    MakeImmutable(poset!.predecessors);
    return poset;
    
end);

